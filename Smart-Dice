getgenv().Toggle = true

-- Debug settings
local DEBUG_MODE = true
local MAX_RETRIES = 5
local RETRY_DELAY = 0.5

local function debugPrint(...)
    if DEBUG_MODE then
        print("[DEBUG]", ...)
    end
end

-- Enhanced remote location finding with fallbacks
local function findRemote(name, remoteType)
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local potentialPaths = {
        "Shared.Framework.Network.Remote." .. name,
        "Shared.Framework.Network." .. name,
        "Framework.Network.Remote." .. name,
        "Network.Remote." .. name,
        "Remotes." .. name,
        name
    }
    
    for _, path in ipairs(potentialPaths) do
        local current = ReplicatedStorage
        local found = true
        
        for part in path:gmatch("[^.]+") do
            if current:FindFirstChild(part) then
                current = current[part]
            else
                found = false
                break
            end
        end
        
        if found then
            if remoteType == "Function" and current:IsA("RemoteFunction") then
                debugPrint("Found RemoteFunction at path:", path)
                return current
            elseif remoteType == "Event" and current:IsA("RemoteEvent") then
                debugPrint("Found RemoteEvent at path:", path)
                return current
            end
        end
    end
    
    return nil
end

-- Initialize remotes with error handling
local Function, Event
local success, err = pcall(function()
    Function = findRemote("Function", "Function") or 
               findRemote("RemoteFunction", "Function") or
               ReplicatedStorage:FindFirstChildWhichIsA("RemoteFunction", true)
    
    Event = findRemote("Event", "Event") or 
            findRemote("RemoteEvent", "Event") or
            ReplicatedStorage:FindFirstChildWhichIsA("RemoteEvent", true)
    
    if not Function then error("Could not find RemoteFunction") end
    if not Event then error("Could not find RemoteEvent") end
end)

if not success then
    warn("Remote initialization failed:", err)
    return
end

-- Load BoardUtil with error handling
local BoardUtil
success, err = pcall(function()
    BoardUtil = require(ReplicatedStorage.Shared.Utils.BoardUtil)
end)

if not success then
    warn("Failed to load BoardUtil:", err)
    return
end

local function RollDice(DiceType: number): number | "Tile Index"
    local diceTypes = {"Dice", "Giant Dice", "Golden Dice"}
    local diceName = diceTypes[DiceType] or "Dice"
    
    debugPrint("Attempting to roll:", diceName)
    
    local retries = 0
    local Returned
    
    while retries < MAX_RETRIES and not Returned do
        retries = retries + 1
        
        success, Returned = pcall(function()
            return Function:InvokeServer("RollDice", diceName)
        end)
        
        if not success then
            warn("RollDice invocation failed (attempt "..retries.."):", Returned)
            Returned = nil
            task.wait(RETRY_DELAY)
        else
            debugPrint("RollDice result:", Returned)
            
            -- Fire claim tile event
            local claimSuccess = pcall(function()
                Event:FireServer("ClaimTile")
            end)
            
            if not claimSuccess then
                warn("ClaimTile event failed to fire")
            end
        end
    end
    
    if not Returned then
        error("Failed to roll dice after "..MAX_RETRIES.." attempts")
    end
    
    return Returned.Tile and Returned.Tile.Index or error("Invalid return from RollDice: Missing Tile.Index")
end

local Status = ""
local function NextDice(TileIndex: number): number | "Dice Type"
    debugPrint("Determining next dice for tile index:", TileIndex)
    
    for Tile = 1, 10 do
        local currentTileIndex = TileIndex + Tile
        
        if currentTileIndex > 88 then
            Status = "Reached the end of the board! Currently starting over by rolling a Dice!"
            debugPrint(Status)
            return 1
        end
        
        local node = BoardUtil.Nodes[currentTileIndex]
        if not node then
            warn("Invalid node at index:", currentTileIndex)
            break
        end
        
        if node.Type == "infinity" then
            Status = string.format("Found Infinity Elixir at Tile: %d | TileIndex: %d", Tile, currentTileIndex)
            debugPrint(Status)
            
            if Tile > 3 and Tile <= 6 or (Tile >= 6 and Tile < 9) then
                return 1    
            elseif Tile >= 9 then
                return 2
            elseif Tile < 3 then
                return 3
            end
        end
    end
    
    Status = "No inf elixir found within depth, rolling indefinitely"
    debugPrint(Status)
    return 1
end

-- Main execution loop with error handling
local function main()
    if not Toggle then return end
    
    debugPrint("Script started with Toggle = true")
    
    local Rolled
    local success, err = pcall(function()
        Rolled = RollDice(1)
    end)
    
    if not success then
        warn("Initial roll failed:", err)
        return
    end
    
    while Toggle do
        success, err = pcall(function()
            local diceType = NextDice(Rolled)
            debugPrint("Next dice type:", diceType)
            
            Rolled = RollDice(diceType)
            print("Rolled to tile:", Rolled, "| Status:", Status)
        end)
        
        if not success then
            warn("Error in main loop:", err)
            -- Optional: add a delay before retrying
            task.wait(1)
        end
    end
end

-- Start the script
main()
