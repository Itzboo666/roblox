-- AUTO-EXEC TELEPORT CLIENT (for Electron App)

-- =============================================================================
--                          USER CONFIGURATION
-- =============================================================================
local WS_URL = "ws://192.168.1.210:8000" -- REPLACE THIS!
local LOCAL_POST_TELEPORT_DELAY_SEC = 3 -- Reduced slightly, server handles main cooldown
local BUSY_FLAG_TIMEOUT_SEC = 30 
-- =============================================================================

-- SERVICES
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService") 
local os_time = os.time
local task_wait = task.wait 
local spawn_thread = task.spawn or spawn 

-- STATE
local isCurrentlyTeleporting = false 
local lastTeleportAttemptTimestamp = 0 
local localPlayer = Players.LocalPlayer

-- DEBUG PRINTING FUNCTION
local function Print(...)
    local args = {...}
    local formattedArgs = {}
    for i = 1, #args do
        table.insert(formattedArgs, tostring(args[i]))
    end
    print("[LuaClient]", table.concat(formattedArgs, "\t"))
end

-- EXECUTOR WEBSOCKET SUPPORT DETECTION
local connect_function
if WebSocket and type(WebSocket.connect) == "function" then
    Print("Using WebSocket.connect API")
    connect_function = WebSocket.connect
elseif WebSocketService and type(WebSocketService.ConnectAsync) == "function" then
    Print("Using WebSocketService:ConnectAsync API")
    connect_function = function(url) return WebSocketService:ConnectAsync(url) end
else
    Print("[Error] No supported WebSocket API found on this executor.")
    return 
end

-- ATTEMPT CONNECTION
local socket
local function attemptConnection()
    Print("[Info] Attempting WebSocket connection to:", WS_URL)
    local success, result = pcall(function()
        socket = connect_function(WS_URL)
    end)
    if not success or not socket then
        Print("[Error] WebSocket connection failed:", result or "No socket object returned")
        return false
    end
    Print("[Info] Successfully connected to WebSocket server:", WS_URL)
    
    if localPlayer and localPlayer.Name then
        local id_payload = {
            type = "identification",
            username = localPlayer.Name,
            userId = localPlayer.UserId
        }
        -- Ensure socket is valid before sending
        if socket and socket.Send then
            local sendSuccess, sendError = pcall(function() socket:Send(HttpService:JSONEncode(id_payload)) end)
            if sendSuccess then
                Print("[Info] Sent identification to server:", localPlayer.Name)
            else
                Print("[Error] Failed to send identification:", sendError)
            end
        else
            Print("[Warning] Socket not valid for sending identification.")
        end
    else
        Print("[Warning] Could not get LocalPlayer name/userId for identification.")
    end
    return true
end

if not attemptConnection() then
    Print("[Fatal] Initial connection failed. Script may not function.")
    return
end

-- HANDLE TELEPORT FAILURES 
TeleportService.TeleportInitFailed:Connect(function(player, result, errorMessage)
    if player == LocalPlayer then
        Print(("[TeleportFail] Teleport failed. Result: %s, Error: %s"):format(tostring(result), tostring(errorMessage)))
        isCurrentlyTeleporting = false 
        if result == Enum.TeleportResult.GameFull then
            Print("[TeleportFail] Server was full. Local delay reset.")
            lastTeleportAttemptTimestamp = 0 
        end
    end
end)

-- WATCHDOG (reverting to a simpler check based on your original script's intent)
spawn_thread(function()
    while task_wait(BUSY_FLAG_TIMEOUT_SEC / 2) do -- Check more frequently
        if isCurrentlyTeleporting and (os_time() - lastTeleportAttemptTimestamp > BUSY_FLAG_TIMEOUT_SEC) then
            Print("[Watchdog] Teleport was busy for > " .. BUSY_FLAG_TIMEOUT_SEC .. "s. Forcibly clearing busy flag.")
            isCurrentlyTeleporting = false
        end
    end
end)

-- HANDLE INCOMING MESSAGES (LUA SCRIPTS) FROM SERVER
socket.OnMessage:Connect(function(messageString)
    Print("[MessageIn] Received raw:", messageString)
    local now = os_time()

    if isCurrentlyTeleporting then
        Print("[Busy] isCurrentlyTeleporting flag is set, skipping new command.")
        return
    end

    if now - lastTeleportAttemptTimestamp < LOCAL_POST_TELEPORT_DELAY_SEC then
        Print(("[LocalDelay] Waiting %d more seconds before next attempt."):format(LOCAL_POST_TELEPORT_DELAY_SEC - (now - lastTeleportAttemptTimestamp)))
        return
    end

    local scriptToExecute = messageString
    Print("[Executing] Attempting to execute script:", scriptToExecute)
    
    isCurrentlyTeleporting = true 
    lastTeleportAttemptTimestamp = now 
    
    -- Directly execute the script using loadstring and pcall for safety
    -- This is closer to how your original Python script's Lua would have been handled
    -- by an executor after being sent.
    local func, compilationError = loadstring(scriptToExecute)
    if not func then
        Print("[Error] loadstring compilation failed:", compilationError)
        isCurrentlyTeleporting = false -- Reset if compilation fails
        return
    end

    local success, executionResult = pcall(func)
    if not success then
        Print("[Error] Script execution via pcall failed:", executionResult)
        -- isCurrentlyTeleporting will be reset by TeleportInitFailed or watchdog in this case
    else
        Print("[Success] Script execution initiated via pcall.")
        -- If teleport is successful, player leaves, script might terminate.
        -- If teleport call itself errors before TeleportService events, TeleportInitFailed might not fire.
        -- Watchdog is a backup.
        -- For many teleports, the script won't reach here if successful as client changes place.
        -- No need to manually set isCurrentlyTeleporting to false here; let events or watchdog handle it.
    end
end)

-- HANDLE SOCKET CLOSURE & RECONNECTION ATTEMPT
if socket.OnClose then
    socket.OnClose:Connect(function(code, reason)
        Print(("[Closed] WebSocket disconnected. Code: %s, Reason: %s"):format(tostring(code), tostring(reason)))
        isCurrentlyTeleporting = false 
        Print("[Info] Attempting to reconnect in 10 seconds...")
        task_wait(10)
        if attemptConnection() then
             Print("[Info] Reconnected successfully after OnClose.")
        else
            Print("[Error] Reconnection after OnClose failed.")
        end
    end)
else
    Print("[Info] socket.OnClose event not available on this executor.")
end

Print("[Info] Lua client setup complete. Waiting for commands...")
