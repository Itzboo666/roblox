-- AUTO-EXEC TELEPORT CLIENT (for Electron App)

-- =============================================================================
--                          USER CONFIGURATION
-- =============================================================================
local WS_URL = "ws://192.168.1.210:8000" -- REPLACE THIS!
local LOCAL_POST_TELEPORT_DELAY_SEC = 5 -- seconds 

local BUSY_FLAG_TIMEOUT_SEC = 30 
-- =============================================================================

-- SERVICES
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService") 
local os_time = os.time
local task_wait = task.wait 
local spawn_thread = task.spawn or spawn -- Compatibility for different executors

-- STATE
local isCurrentlyTeleporting = false 
local lastTeleportAttemptTimestamp = 0 -- Renamed for clarity
local localPlayer = Players.LocalPlayer

-- DEBUG PRINTING FUNCTION
local function Print(...)
    local args = {...}
    local formattedArgs = {}
    for i = 1, #args do
        table.insert(formattedArgs, tostring(args[i]))
    end
    print("[LuaClient]", table.concat(formattedArgs, "\t"))
end

-- EXECUTOR WEBSOCKET SUPPORT DETECTION
local connect_function
if WebSocket and type(WebSocket.connect) == "function" then
    Print("Using WebSocket.connect API")
    connect_function = WebSocket.connect
elseif WebSocketService and type(WebSocketService.ConnectAsync) == "function" then
    Print("Using WebSocketService:ConnectAsync API")
    connect_function = function(url) return WebSocketService:ConnectAsync(url) end
else
    Print("[Error] No supported WebSocket API found on this executor.")
    return 
end

-- ATTEMPT CONNECTION
local socket
local function attemptConnection()
    Print("[Info] Attempting WebSocket connection to:", WS_URL)
    local success, result = pcall(function()
        socket = connect_function(WS_URL)
    end)
    if not success or not socket then
        Print("[Error] WebSocket connection failed:", result or "No socket object returned")
        return false
    end
    Print("[Info] Successfully connected to WebSocket server:", WS_URL)
    
    if localPlayer and localPlayer.Name then
        local id_payload = {
            type = "identification",
            username = localPlayer.Name,
            userId = localPlayer.UserId
        }
        pcall(function() 
            if socket and socket.Send then socket:Send(HttpService:JSONEncode(id_payload)) end
        end)
        Print("[Info] Sent identification to server:", localPlayer.Name)
    else
        Print("[Warning] Could not get LocalPlayer name for identification.")
    end
    return true
end

if not attemptConnection() then
    Print("[Fatal] Initial connection failed. Script may not function.")
    return
end

-- HANDLE TELEPORT FAILURES (e.g., Server Full) - Reverting to simpler logic
TeleportService.TeleportInitFailed:Connect(function(player, result, errorMessage)
    if player == LocalPlayer then
        Print(("[TeleportFail] Teleport failed. Result: %s, Error: %s"):format(tostring(result), tostring(errorMessage)))
        isCurrentlyTeleporting = false -- Reset busy flag immediately on any failure
        if result == Enum.TeleportResult.GameFull then
            Print("[TeleportFail] Server was full. Allowing immediate retry if new command comes.")
            lastTeleportAttemptTimestamp = 0 -- Reset local delay as main server will handle cooldown
        end
    end
end)

-- WATCHDOG: Forcibly clear busy flag if no TeleportInitFailed event after a timeout
spawn_thread(function()
    while true do
        task_wait(BUSY_FLAG_TIMEOUT_SEC)
        if isCurrentlyTeleporting then
             -- If busy for longer than the timeout, and no TeleportInitFailed occurred,
             -- assume it might be stuck or succeeded without event (less likely but possible).
            Print("[Watchdog] Teleport was busy for too long. Forcibly clearing busy flag.")
            isCurrentlyTeleporting = false
        end
    end
end)

-- HANDLE INCOMING MESSAGES (LUA SCRIPTS) FROM SERVER
socket.OnMessage:Connect(function(messageString)
    Print("[MessageIn] Received raw:", messageString)
    local now = os_time()

    if isCurrentlyTeleporting then
        Print("[Busy] isCurrentlyTeleporting flag is set, skipping new command.")
        return
    end

    -- The main cooldown is on the server (Electron app), but this is a small local buffer.
    if now - lastTeleportAttemptTimestamp < LOCAL_POST_TELEPORT_DELAY_SEC then
        Print(("[LocalDelay] Waiting %d more seconds before next attempt."):format(LOCAL_POST_TELEPORT_DELAY_SEC - (now - lastTeleportAttemptTimestamp)))
        return
    end

    local scriptToExecute = messageString
    Print("[Executing] Attempting to execute script:", scriptToExecute)
    
    local func, executionError = loadstring(scriptToExecute)
    if not func then
        Print("[Error] loadstring failed:", executionError)
        return
    end

    isCurrentlyTeleporting = true 
    lastTeleportAttemptTimestamp = now -- Record time of this attempt
    
    local success, result = pcall(func)
    if not success then
        Print("[Error] Script execution failed:", result)
        -- isCurrentlyTeleporting will be reset by TeleportInitFailed or watchdog
    else
        Print("[Success] Script execution initiated via pcall.")
        -- We don't reset isCurrentlyTeleporting here; TeleportInitFailed or the watchdog will handle it.
        -- If the teleport succeeds, the player leaves the server, and this script instance ends.
        -- If it fails, TeleportInitFailed should catch it.
        -- If neither, watchdog eventually clears it.
    end
end)

-- HANDLE SOCKET CLOSURE & RECONNECTION ATTEMPT
if socket.OnClose then
    socket.OnClose:Connect(function(code, reason)
        Print(("[Closed] WebSocket disconnected. Code: %s, Reason: %s"):format(tostring(code), tostring(reason)))
        isCurrentlyTeleporting = false 
        Print("[Info] Attempting to reconnect in 10 seconds...")
        task_wait(10)
        if attemptConnection() then
             Print("[Info] Reconnected successfully after OnClose.")
        else
            Print("[Error] Reconnection after OnClose failed.")
        end
    end)
else
    Print("[Info] socket.OnClose event not available on this executor.")
end

Print("[Info] Lua client setup complete. Waiting for commands...")
