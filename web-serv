-- AUTO-EXEC TELEPORT CLIENT

-- CONFIGURATION: your ngrok tunnel WS URL
local WS_URL        = "wss://34d5-2a00-23c7-148c-9801-d03a-c5e6-1859-6c03.ngrok-free.app/ws"
local COOLDOWN_SEC  = 8 * 60  -- 8 minutes

-- SERVICES
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local os_time         = os.time

-- STATE
local lastTeleport = 0
local busy         = false
local currentJobId = nil

-- EXECUTOR WS SUPPORT
local connect
if WebSocket and type(WebSocket.connect) == "function" then
    connect = WebSocket.connect
elseif WebSocketService and type(WebSocketService.ConnectAsync) == "function" then
    connect = function(url) return WebSocketService:ConnectAsync(url) end
else
    warn("[WebSocket] No supported API (WebSocket.connect or WSService:ConnectAsync).")
    return
end

-- CONNECT
local ok, socket = pcall(connect, WS_URL)
if not ok or not socket then
    warn("[WebSocket] Connection failed:", socket)
    return
end
print("[WebSocket] Connected to:", WS_URL)

-- RESET on GameFull or other failures
TeleportService.TeleportInitFailed:Connect(function(player, result)
    if player == Players.LocalPlayer then
        warn("[Teleport] Teleport failed ("..tostring(result)..") - clearing busy flag")
        busy = false
        currentJobId = nil
    end
end)

-- Handle successful teleport completion
if TeleportService.TeleportCompleted then
    TeleportService.TeleportCompleted:Connect(function(player)
        if player == Players.LocalPlayer then
            print("[Teleport] Successfully teleported - starting cooldown")
            lastTeleport = os_time()
            busy = false
            currentJobId = nil
        end
    end)
end

-- Watchdog to clear stuck states
spawn(function()
    while true do
        task.wait(30)
        local now = os_time()
        if busy and now - lastTeleport > COOLDOWN_SEC then
            print("[Watchdog] Clearing busy flag after timeout")
            busy = false
            currentJobId = nil
        end
    end
end)

-- ON MESSAGE
socket.OnMessage:Connect(function(msg)
    print("[WebSocket] Received message:", msg)
    local now = os_time()
    
    -- Parse the message (assuming it's JSON with job_id and command)
    local success, data = pcall(function()
        return game:GetService("HttpService"):JSONDecode(msg)
    end)
    
    if not success then
        warn("[WebSocket] Invalid JSON message")
        return
    end
    
    local jobId = data.job_id
    local command = data.command
    
    if not jobId or not command then
        warn("[WebSocket] Missing job_id or command in message")
        return
    end
    
    -- Skip if we're already processing this job
    if currentJobId == jobId then
        print("[Job] Already processing this job, skipping")
        return
    end
    
    -- Cooldown checks
    if busy then
        warn("[Cooldown] Currently processing another teleport")
        return
    end
    
    if now - lastTeleport < COOLDOWN_SEC then
        local remaining = COOLDOWN_SEC - (now - lastTeleport)
        warn(("[Cooldown] %d minutes %d seconds remaining"):format(
            math.floor(remaining / 60),
            remaining % 60
        ))
        return
    end
    
    -- compile & execute
    local fn, err = loadstring(command)
    if not fn then
        warn("[WebSocket] loadstring error:", err)
        return
    end

    print("[Teleport] Executing teleport command for job:", jobId)
    busy = true
    currentJobId = jobId
    lastTeleport = now
    
    local success, err = pcall(fn)
    if not success then
        warn("[Teleport] Execution error:", err)
        busy = false
        currentJobId = nil
    end
end)

-- ON CLOSE
if socket.OnClose then
    socket.OnClose:Connect(function(code, reason)
        warn(("[WebSocket] Disconnected (%s): %s"):format(tostring(code), tostring(reason)))
    end
end
