-- --- START OF ENTIRE Websocket-lua.txt (with setfenv and TeleportInitFailed for Error 772) ---

local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local TextChatService = game:GetService("TextChatService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local WEBSOCKET_SERVER_URL = "ws://192.168.1.210:8080" -- ENSURE IP AND PORT ARE CORRECT (8000 is Electron default)
local RECONNECT_DELAY = 7
local PING_INTERVAL = 25

local ws_client
local instanceIdFromServer = nil
local is_connected = false
local last_ping_sent = 0
local connection_attempt_active = false
local current_teleport_job_id = nil -- To track the job ID we are trying to join

-- _try_attach_event function (standard helper)
local function _try_attach_event(client, event_config, callback)
    local s_access, prop, s_connect_access, connect_fn, s_call, err_call
    s_access, prop = pcall(function() return client[event_config.PascalEvent] end)
    if s_access and prop and type(prop) == "table" then
        s_connect_access, connect_fn = pcall(function() return prop.Connect end)
        if s_connect_access and connect_fn and type(connect_fn) == "function" then
            s_call, err_call = pcall(function() prop:Connect(callback) end)
            if s_call then return true, event_config.PascalEvent .. ":Connect" end
        end
    end
    s_access, prop = pcall(function() return client[event_config.snake_event] end)
    if s_access and prop and type(prop) == "table" then
        s_connect_access, connect_fn = pcall(function() return prop.connect end)
        if s_connect_access and connect_fn and type(connect_fn) == "function" then
            s_call, err_call = pcall(function() prop:connect(callback) end)
            if s_call then return true, event_config.snake_event .. ":connect" end
        end
    end
    s_access, prop = pcall(function() return client.on end)
    if s_access and prop and type(prop) == "function" then
        s_call, err_call = pcall(function() client:on(event_config.emitter_event, callback) end)
        if s_call then return true, "client:on('" .. event_config.emitter_event .. "')" end
    end
    if event_config.direct_on_event then
        s_call, err_call = pcall(function() client[event_config.direct_on_event] = callback end)
        if s_call then 
            s_access, prop = pcall(function() return client[event_config.direct_on_event] end)
            if s_access and type(prop) == "function" then return true, "." .. event_config.direct_on_event end
        end
    end
    if event_config.direct_on_underscore_event then
        s_call, err_call = pcall(function() client[event_config.direct_on_underscore_event] = callback end)
        if s_call then
            s_access, prop = pcall(function() return client[event_config.direct_on_underscore_event] end)
            if s_access and type(prop) == "function" then return true, "." .. event_config.direct_on_underscore_event end
        end
    end
    return false
end

-- _try_send_message function (standard helper)
local function _try_send_message(client, data_string)
    local success, err_msg, method_name
    method_name = "client:send()"
    success, err_msg = pcall(function() client:send(data_string) end)
    if success then return true, method_name end
    method_name = "client.send()"
    success, err_msg = pcall(function() client.send(data_string) end)
    if success then return true, method_name end
    method_name = "client:Send()"
    success, err_msg = pcall(function() client:Send(data_string) end)
    if success then return true, method_name end
    method_name = "client.Send()"
    success, err_msg = pcall(function() client.Send(data_string) end)
    if success then return true, method_name end
    return false, err_msg 
end

-- send_ws_message function (standard helper)
local function send_ws_message(data_table)
    if not (ws_client and (is_connected or data_table.type == "identity_report")) then
        if not (data_table.type == "identity_report" and ws_client) then
            -- warn("[SNIPER_LUA_WS] Not sending message: WS client not ready or not connected. Type: " .. (data_table.type or "N/A"))
            return
        end
    end
    local success_json, json_data = pcall(HttpService.JSONEncode, HttpService, data_table)
    if not success_json or not ws_client then
        if not success_json then warn("[SNIPER_LUA_WS] JSONEncode failed: " .. tostring(json_data)) end
        if not ws_client then warn("[SNIPER_LUA_WS] WS client is nil, cannot send.") end
        return
    end
    local sent, method_or_error = _try_send_message(ws_client, json_data)
    if not sent then
        warn("[SNIPER_LUA_WS] All WebSocket send methods failed. Last error: " .. tostring(method_or_error))
    end
end

-- send_identity_report function (standard helper)
local function send_identity_report()
    if not Players.LocalPlayer then
        warn("[SNIPER_LUA_ID] LocalPlayer not available for identity report. Will retry.")
        task.wait(1)
        if not Players.LocalPlayer then
            warn("[SNIPER_LUA_ID] LocalPlayer still not available after retry.")
            return
        end
    end
    local userId = Players.LocalPlayer.UserId
    local userName = Players.LocalPlayer.Name
    if userId and userName then
        -- warn("[SNIPER_LUA_ID] Sending identity report for UserID: " .. userId .. ", UserName: " .. userName)
        send_ws_message({
            type = "identity_report",
            userId = tostring(userId),
            userName = userName
        })
    else
        warn("[SNIPER_LUA_ID] Could not send identity report: UserId or UserName missing.")
    end
end

-- MODIFIED handle_server_message (with setfenv for loadstring)
local function handle_server_message(message_string)
    local decoded_successfully, data_or_error = pcall(HttpService.JSONDecode, HttpService, message_string)

    if decoded_successfully then
        local data = data_or_error
        if data.type == "connected" then
            warn("[SNIPER_LUA_WS] Received 'connected' from server. InstanceID: " .. (data.instanceId or "N/A"))
            instanceIdFromServer = data.instanceId
            is_connected = true
            local server_tells_us_status = data.status
            if server_tells_us_status == 'idle' then
                send_ws_message({ type = "status_update", status = "idle" })
            elseif not server_tells_us_status and not (server_tells_us_status == "active_cooldown" or server_tells_us_status == "teleport_sent_awaiting_disconnect" or server_tells_us_status == "teleport_initiated_awaiting_reconnect") then
                send_ws_message({ type = "status_update", status = "idle" })
            end
        elseif data.type == "ping" then
            send_ws_message({ type = "pong" })
        elseif data.type == "error" and data.message == "Identity not established." then
            warn("[SNIPER_LUA_WS] Received 'Identity not established' error. Resending identity.")
            send_identity_report()
        elseif data.type == "send_chat_to_roblox" and data.message then
            warn("[SNIPER_LUA_CHAT] Received 'send_chat_to_roblox': ", HttpService:JSONEncode(data))
            local messageToSend = tostring(data.message)
            local messageSent = false
            if TextChatService then
                local targetChannel = nil
                if TextChatService:FindFirstChild("ChatInputBarConfiguration") then
                    local inputBarConfig = TextChatService.ChatInputBarConfiguration
                    targetChannel = inputBarConfig:GetAttribute("TargetTextChannel") or inputBarConfig.TargetTextChannel
                    if targetChannel and targetChannel:IsA("TextChannel") then
                        local s, e = pcall(function() targetChannel:SendAsync(messageToSend) end)
                        if s then messageSent = true; send_ws_message({type="feedback", status="success", message="Lua: Sent chat (InputBar Target)"}) else send_ws_message({type="feedback", status="error", message="Lua: Failed InputBar Target: " .. tostring(e)}) end
                    end
                end
                if not messageSent then
                    local channels = TextChatService:GetChildren()
                    local preferredChannel = nil
                    for _, channel in ipairs(channels) do if channel:IsA("TextChannel") and (string.lower(channel.Name) == "rbxsystem" or string.lower(channel.Name) == "all" or string.find(string.lower(channel.Name), "general")) then preferredChannel = channel; break; end end
                    if not preferredChannel then for _, channel in ipairs(channels) do if channel:IsA("TextChannel") then preferredChannel = channel; break; end end end
                    if preferredChannel then
                        local s, e = pcall(function() preferredChannel:SendAsync(messageToSend) end)
                        if s then messageSent = true; send_ws_message({type="feedback", status="success", message="Lua: Sent chat (Fallback TCS)"}) else send_ws_message({type="feedback", status="error", message="Lua: Failed Fallback TCS: " .. tostring(e)}) end
                    else send_ws_message({type="feedback", status="error", message="Lua: No TextChannel (fallback)."}) end
                end
            end
            if not messageSent then
                local ChatService = game:GetService("Chat")
                if ChatService and Players.LocalPlayer and Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChild("Head") then
                    local s, e = pcall(function() ChatService:Chat(Players.LocalPlayer.Character.Head, messageToSend, Enum.ChatColor.Blue) end)
                    if s then messageSent = true; send_ws_message({type="feedback", status="success", message="Lua: Sent chat (Legacy)."}) else send_ws_message({type="feedback", status="error", message="Lua: Failed Legacy Chat: " .. tostring(e)}) end
                else if not messageSent then send_ws_message({type="feedback", status="error", message="Lua: All chat methods failed."}) end end
            end
        else
            warn("[SNIPER_LUA_WS] Received valid JSON but unknown or unhandled type: " .. (data.type or "nil"))
        end
    else
        -- JSON decoding FAILED. Assume it's a raw Lua script string to execute.
        warn("[SNIPER_LUA_WS] JSON decode failed (" .. tostring(data_or_error) .. "). Assuming raw script: " .. message_string)
        if typeof(loadstring) == "function" then
            local func, err_load = loadstring(message_string)
            if func then
                -- Set the environment for the loaded function
                local chunkEnv = getfenv(func) 
                if chunkEnv then
                    chunkEnv.game = game 
                    chunkEnv.print = print 
                    chunkEnv.warn = warn   
                    chunkEnv.GetService = function(serviceName) return game:GetService(serviceName) end
                    chunkEnv.TeleportService = TeleportService 
                    chunkEnv.Players = Players
                    -- Add other necessary globals if the script string needs them
                else
                    warn("[SNIPER_LUA_EXEC] Could not get environment of loaded function.")
                end
                setfenv(func, chunkEnv) -- Apply the environment

                local match_job_id = string.match(message_string, 'TeleportToPlaceInstance%s*%(%s*%d+%s*,%s*["%'](.-)["%']%s*%)')
                if match_job_id then
                    current_teleport_job_id = match_job_id
                    warn("[SNIPER_LUA_EXEC] Identified teleport script for JobID: " .. current_teleport_job_id)
                else
                    current_teleport_job_id = nil 
                end

                send_ws_message({ type = "status_update", status = "executing_script", jobId = current_teleport_job_id or "N/A" })
                
                local exec_success, err_exec = pcall(func) 
                if not exec_success then
                    warn("[SNIPER_LUA_EXEC] Error executing received script: " .. tostring(err_exec))
                    send_ws_message({ type = "feedback", status = "error", message = "Lua: Error executing script: " .. tostring(err_exec), jobId = current_teleport_job_id or "N/A" })
                    current_teleport_job_id = nil 
                else
                    warn("[SNIPER_LUA_EXEC] Raw script initiated/executed successfully (JobID: " .. (current_teleport_job_id or "N/A") .. ").")
                    if not current_teleport_job_id then
                         send_ws_message({ type = "feedback", status = "success", message = "Lua: Non-teleport script executed."})
                    end
                end
            else
                warn("[SNIPER_LUA_EXEC] loadstring failed to compile script: " .. tostring(err_load))
                send_ws_message({ type = "feedback", status = "error", message = "Lua: loadstring compile error: " .. tostring(err_load) })
            end
        else
            warn("[SNIPER_LUA_EXEC] loadstring function is not available in this environment.")
            send_ws_message({ type = "feedback", status = "error", message = "Lua: loadstring not available." })
        end
    end
end

-- TeleportInitFailed Handler (for Error 772 and others)
local function onTeleportInitFailed(player, teleportResult, errorMessage, placeId, teleportOptions)
    warn(("[SNIPER_LUA_TP_FAIL] TeleportInitFailed. Player: %s, Result: %s, Error: %s, PlaceID: %s"):format(
        player.Name, tostring(teleportResult), tostring(errorMessage), tostring(placeId)
    ))
    local resultString = tostring(teleportResult); local errorCode = string.match(resultString, "%d+"); if errorCode then errorCode = tonumber(errorCode) end
    warn("[SNIPER_LUA_TP_FAIL] Parsed ErrorCode: " .. tostring(errorCode) .. " (from result: " .. resultString .. ")")
    if current_teleport_job_id then
        warn("[SNIPER_LUA_TP_FAIL] This failure is for JobID: " .. current_teleport_job_id)
        if errorCode == 772 then
            warn("[SNIPER_LUA_TP_FAIL] Teleport failed because server is full (Error 772). Sending feedback.")
            send_ws_message({ type = "feedback", status = "teleport_failed_server_full", message = "Lua: Teleport failed - server full (Error 772).", jobId = current_teleport_job_id, errorCode = 772 })
        else
            warn("[SNIPER_LUA_TP_FAIL] Teleport failed for other reason. Sending generic failure feedback.")
            send_ws_message({ type = "feedback", status = "teleport_failed_other", message = "Lua: Teleport failed - " .. resultString .. " (" .. errorMessage .. ")", jobId = current_teleport_job_id, errorCode = errorCode or "Unknown" })
        end
        current_teleport_job_id = nil
    else
        warn("[SNIPER_LUA_TP_FAIL] TeleportInitFailed, but no current_teleport_job_id was being tracked.")
    end
    send_ws_message({ type = "status_update", status = "idle" })
end
TeleportService.TeleportInitFailed:Connect(onTeleportInitFailed)

-- setup_chat_listeners function (unchanged)
local function setup_chat_listeners()
    if TextChatService then
        warn("[SNIPER_LUA_CHAT_LISTEN] Setting up TextChatService.MessageReceived listener.")
        TextChatService.MessageReceived:Connect(function(textChatMessage)
            if not is_connected then return end
            local authorUserId = "System"; local authorDisplayName = "System"; local messageText = textChatMessage.Text
            local timestamp; if textChatMessage.Timestamp and typeof(textChatMessage.Timestamp) == "DateTime" then if textChatMessage.Timestamp.UnixTimestampMillis then timestamp = math.floor(textChatMessage.Timestamp.UnixTimestampMillis / 1000) elseif textChatMessage.Timestamp.UnixTimestamp then timestamp = textChatMessage.Timestamp.UnixTimestamp else timestamp = os.time() end else timestamp = os.time() end
            if textChatMessage.TextSource then authorUserId = tostring(textChatMessage.TextSource.UserId); local sourcePlayer = Players:GetPlayerByUserId(textChatMessage.TextSource.UserId)
                if sourcePlayer then authorDisplayName = sourcePlayer.DisplayName; if not authorDisplayName or authorDisplayName == "" then authorDisplayName = sourcePlayer.Name end
                else local tsName = "UnknownPlayer"; local s, nV = pcall(function() return textChatMessage.TextSource.Name end); if s and nV then tsName = nV end; authorDisplayName = tsName end
            end
            send_ws_message({type = "chat_message_from_client", authorUserId = authorUserId, authorDisplayName = authorDisplayName, message = messageText, timestamp = timestamp})
        end)
    else
        warn("[SNIPER_LUA_CHAT_LISTEN] TextChatService not found. Setting up legacy chat listeners.")
        local function handle_legacy_chat(player, message, eventType)
            if not is_connected then return end
            local payload = {type = "chat_message_from_client", authorUserId = tostring(player.UserId), authorDisplayName = player.Name, message = message, timestamp = os.time()}
            if player.DisplayName and player.DisplayName ~= "" then payload.authorDisplayName = player.DisplayName end
            send_ws_message(payload)
        end
        Players.PlayerAdded:Connect(function(player) player.Chatted:Connect(function(message) handle_legacy_chat(player, message, "PlayerAdded.Chatted") end) end)
        for _, player in ipairs(Players:GetPlayers()) do player.Chatted:Connect(function(message) handle_legacy_chat(player, message, "ExistingPlayer.Chatted") end) end
        if Players.LocalPlayer then local eC; eC = Players.LocalPlayer.Chatted:Connect(function(message) if not Players.LocalPlayer then if eC then eC:Disconnect() end return end handle_legacy_chat(Players.LocalPlayer, message, "LocalPlayer.Chatted") end) end
    end
end

-- connect_websocket function (unchanged)
local function connect_websocket()
    if connection_attempt_active then warn("[SNIPER_LUA_WS] Connection attempt already active. Skipping."); return end
    warn("[SNIPER_LUA_WS] Attempting to connect WebSocket..."); connection_attempt_active = true; is_connected = false
    if ws_client and ws_client.close then warn("[SNIPER_LUA_WS] Closing existing WebSocket client."); pcall(ws_client.close, ws_client) end; ws_client = nil
    local function _hMW(mD) local mC=mD; if type(mD)=="table" and mD.data then mC=mD.data end; if type(mC)=="string" then handle_server_message(mC) end end
    local function _hCW(c,r) warn(("[SNIPER_LUA_WS] WebSocket closed. Code: %s, Reason: %s. Reconnecting in %ss."):format(tostring(c),tostring(r),RECONNECT_DELAY)); is_connected=false;ws_client=nil;connection_attempt_active=false;task.wait(RECONNECT_DELAY);connect_websocket() end
    local function _hEW(e) warn(("[SNIPER_LUA_WS] WebSocket error: %s. Reconnecting in %ss."):format(tostring(e),RECONNECT_DELAY)); if is_connected then pcall(function() if ws_client and ws_client.close then ws_client:close() end end) end; is_connected=false;ws_client=nil;connection_attempt_active=false;task.wait(RECONNECT_DELAY);connect_websocket() end
    local exLibN="Unknown"; if syn and syn.websocket and syn.websocket.connect then exLibN="syn.websocket"; warn("[SNIPER_LUA_WS] Using "..exLibN); local cS,nC=pcall(function() return syn.websocket.connect(WEBSOCKET_SERVER_URL) end); if not cS or not nC then warn(("[SNIPER_LUA_WS] %s.connect failed: %s"):format(exLibN,tostring(nC)));connection_attempt_active=false;task.wait(RECONNECT_DELAY);connect_websocket();return end; ws_client=nC;ws_client.OnMessage:Connect(_hMW);ws_client.OnClose:Connect(_hCW);if ws_client.OnError then ws_client.OnError:Connect(_hEW) else warn("[SNIPER_LUA_WS] "..exLibN.." has no OnError event.") end; warn("[SNIPER_LUA_WS] "..exLibN.." events connected.");connection_attempt_active=false;send_identity_report();setup_chat_listeners()
    elseif WebSocket and WebSocket.connect then exLibN="WebSocket (generic)"; warn("[SNIPER_LUA_WS] Using "..exLibN); local sC,cOE=pcall(WebSocket.connect,WEBSOCKET_SERVER_URL); if not sC or not cOE then warn(("[SNIPER_LUA_WS] %s.connect failed: %s"):format(exLibN,tostring(cOE)));connection_attempt_active=false;task.wait(RECONNECT_DELAY);connect_websocket();return end; ws_client=cOE; local mEC={PascalEvent="OnMessage",snake_event="on_message",direct_on_event="onmessage",direct_on_underscore_event="on_message",emitter_event="message"}; local cEC={PascalEvent="OnClose",snake_event="on_close",direct_on_event="onclose",direct_on_underscore_event="on_close",emitter_event="close"}; local eEC={PascalEvent="OnError",snake_event="on_error",direct_on_event="onerror",direct_on_underscore_event="on_error",emitter_event="error"}; local aM,mM=_try_attach_event(ws_client,mEC,_hMW);if not aM then warn("[SNIPER_LUA_WS] "..exLibN..": No msg handler.") else warn("[SNIPER_LUA_WS] "..exLibN.." Msg: "..mM) end; local aC,cM=_try_attach_event(ws_client,cEC,_hCW);if not aC then warn("[SNIPER_LUA_WS] "..exLibN..": No close handler.") else warn("[SNIPER_LUA_WS] "..exLibN.." Close: "..cM) end; local aE,eM=_try_attach_event(ws_client,eEC,_hEW);if not aE then warn("[SNIPER_LUA_WS] "..exLibN..": No error handler.") else warn("[SNIPER_LUA_WS] "..exLibN.." Error: "..eM) end; warn("[SNIPER_LUA_WS] "..exLibN.." events attempted.");connection_attempt_active=false;if not(aM and aC)then warn("[SNIPER_LUA_WS] Critical "..exLibN.." handlers not attached. Reconnecting.");if ws_client.close then pcall(ws_client.close,ws_client)end;ws_client=nil;is_connected=false;task.wait(RECONNECT_DELAY);connect_websocket();return end;send_identity_report();setup_chat_listeners()
    else warn("[SNIPER_LUA_WS] No WebSocket library found. Cannot connect.");connection_attempt_active=false;return end
end

warn("[SNIPER_LUA_CORE] Script initiated. Attempting initial WebSocket connection.")
connect_websocket()

spawn(function()
    while task.wait(PING_INTERVAL) do
        if ws_client and is_connected and tick() - last_ping_sent > PING_INTERVAL - 2 then
            send_ws_message({type = "ping_from_client"})
            last_ping_sent = tick()
        elseif not is_connected and not connection_attempt_active and (syn and syn.websocket or WebSocket) then 
             warn("[SNIPER_LUA_PING_LOOP] Not connected and no active attempt. Re-initiating connection.")
             connect_websocket()
        end
    end
end)

warn("[SNIPER_LUA_CORE] Script main execution finished. Background tasks (WS, ping) are running.")
-- --- END OF ENTIRE MODIFIED Websocket-lua.txt ---
