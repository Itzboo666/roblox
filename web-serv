-- AUTO-EXEC TELEPORT CLIENT (for Electron App)

-- =============================================================================
--                          USER CONFIGURATION
-- =============================================================================
local WS_URL = "ws://192.168.1.210:8000" -- REPLACE THIS!
local LOCAL_POST_TELEPORT_DELAY_SEC = 5 
-- =============================================================================

-- SERVICES
local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService") 
local os_time = os.time
local task_wait = task.wait 

-- STATE
local isCurrentlyTeleporting = false 
local lastAttemptTimestamp = 0
local localPlayer = Players.LocalPlayer

-- DEBUG PRINTING FUNCTION
local function Print(...)
    local args = {...}
    local formattedArgs = {}
    for i = 1, #args do
        table.insert(formattedArgs, tostring(args[i]))
    end
    print("[LuaClient]", table.concat(formattedArgs, "\t"))
end

-- EXECUTOR WEBSOCKET SUPPORT DETECTION
local connect_function
if WebSocket and type(WebSocket.connect) == "function" then
    Print("Using WebSocket.connect API")
    connect_function = WebSocket.connect
elseif WebSocketService and type(WebSocketService.ConnectAsync) == "function" then
    Print("Using WebSocketService:ConnectAsync API")
    connect_function = function(url) return WebSocketService:ConnectAsync(url) end
else
    Print("[Error] No supported WebSocket API found on this executor.")
    return 
end

-- ATTEMPT CONNECTION
local socket
local function attemptConnection()
    Print("[Info] Attempting WebSocket connection to:", WS_URL)
    local success, result = pcall(function()
        socket = connect_function(WS_URL)
    end)
    if not success or not socket then
        Print("[Error] WebSocket connection failed:", result or "No socket object returned")
        return false
    end
    Print("[Info] Successfully connected to WebSocket server:", WS_URL)
    
    -- Send initial identification message with Roblox username
    if localPlayer and localPlayer.Name then
        local id_payload = {
            type = "identification",
            username = localPlayer.Name,
            userId = localPlayer.UserId -- Sending UserId as well might be useful
        }
        pcall(function() socket:Send(HttpService:JSONEncode(id_payload)) end)
        Print("[Info] Sent identification to server:", localPlayer.Name)
    else
        Print("[Warning] Could not get LocalPlayer name for identification.")
    end
    return true
end

if not attemptConnection() then
    Print("[Fatal] Initial connection failed. Script may not function.")
    return
end


-- HANDLE TELEPORT FAILURES / STATE CHANGES
TeleportService.TeleportInitFailed:Connect(function(player, result, errorMessage)
    if player == LocalPlayer then
        Print(("[TeleportFail] Teleport failed. Result: %s, Error: %s"):format(tostring(result), tostring(errorMessage)))
        isCurrentlyTeleporting = false 
        if result == Enum.TeleportResult.GameFull then
            lastAttemptTimestamp = 0 
        end
    end
end)

TeleportService.TeleportStateChanged:Connect(function(oldState, newState)
    Print(("[TeleportState] %s -> %s"):format(tostring(oldState), tostring(newState)))
    if newState == Enum.TeleportState.Teleported or newState == Enum.TeleportState.Failed then
        Print("[TeleportState] Teleport sequence concluded. Resetting local busy state.")
        isCurrentlyTeleporting = false
    elseif newState == Enum.TeleportState.InProgress then
        isCurrentlyTeleporting = true 
    end
end)

-- HANDLE INCOMING MESSAGES (LUA SCRIPTS) FROM SERVER
socket.OnMessage:Connect(function(messageString)
    Print("[MessageIn] Received raw:", messageString)
    local now = os_time()

    if isCurrentlyTeleporting then
        Print("[Busy] Currently attempting a teleport, skipping new command.")
        return
    end

    if now - lastAttemptTimestamp < LOCAL_POST_TELEPORT_DELAY_SEC then
        Print(("[LocalDelay] Waiting %d more seconds before next attempt."):format(LOCAL_POST_TELEPORT_DELAY_SEC - (now - lastAttemptTimestamp)))
        return
    end

    local scriptToExecute = messageString
    Print("[Executing] Attempting to execute script:", scriptToExecute)
    
    local func, executionError = loadstring(scriptToExecute)
    if not func then
        Print("[Error] loadstring failed:", executionError)
        return
    end

    isCurrentlyTeleporting = true 
    lastAttemptTimestamp = now
    
    local success, result = pcall(func)
    if not success then
        Print("[Error] Script execution failed:", result)
        isCurrentlyTeleporting = false 
    else
        Print("[Success] Script executed.")
    end
end)

-- HANDLE SOCKET CLOSURE & RECONNECTION ATTEMPT
if socket.OnClose then
    socket.OnClose:Connect(function(code, reason)
        Print(("[Closed] WebSocket disconnected. Code: %s, Reason: %s"):format(tostring(code), tostring(reason)))
        isCurrentlyTeleporting = false -- Reset busy state on disconnect
        Print("[Info] Attempting to reconnect in 10 seconds...")
        task_wait(10)
        if attemptConnection() then
             Print("[Info] Reconnected successfully after OnClose.")
             -- Re-attach OnMessage and OnClose if the WebSocket library requires it upon new socket object
             -- For many executors, the global 'socket' variable being updated is enough.
        else
            Print("[Error] Reconnection after OnClose failed.")
        end
    end)
else
    Print("[Info] socket.OnClose event not available on this executor.")
end

Print("[Info] Lua client setup complete. Waiting for commands...")
